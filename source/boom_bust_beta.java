/* autogenerated by Processing revision 1289 on 2023-04-26 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import processing.sound.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class boom_bust_beta extends PApplet {


SoundFile sound;
SoundFile song;

ArrayList<StringDict> dialogue_tree;
StringDict lvl1_dialogue;
StringDict lvl2_dialogue;
StringDict lvl3_dialogue;
StringDict lvl4_dialogue;
StringDict lvl5_dialogue;

int screen = 0;
int num_lvls = 5;
boolean muted = false;

PFont expo;
PFont arial;
PImage title_sign;
PImage bomb;
PImage belt;
PImage matchless_belt;
PImage match;
PImage cityscape;
PImage mobster;
PImage tutorial;
PImage red_arrow;
PImage title_screen_buttons;
PImage[] explosion = new PImage[9];
PImage[] door = new PImage[num_lvls];
PImage[] behind_door = new PImage[num_lvls];

IntList empty_list;
IntList lvl1_l1;
IntList lvl2_l1;
IntList lvl3_l1;
IntList lvl3_l2;
IntList lvl4_l1;
IntList lvl4_l2;
IntList lvl4_l3;
IntList lvl5_l1;
IntList lvl5_l2;
IntList lvl5_l3;

TitleScreen title_screen;
Level lvl1;
Level lvl2;
Level lvl3;
Level lvl4;
Level lvl5;

public void setup() {
  /* size commented out by preprocessor */;
  
  sound = new SoundFile(this, "assets/explosion.mp3");
  song  = new SoundFile(this, "assets/saint-motel-benny-goodman.mp3");
  
  expo = createFont("assets/explosion_book_bold.ttf", 128);
  arial = createFont("assets/arial.ttf", 128);
  title_sign = loadImage("assets/title_sign.png");
  bomb = loadImage("assets/bomb.png");
  belt = loadImage("assets/belt.png");
  matchless_belt = loadImage("assets/matchless_belt.png");
  match = loadImage("assets/match.png");
  cityscape = loadImage("assets/cityscape.png");
  mobster = loadImage("assets/mobster.png");
  tutorial = loadImage("assets/tutorial.png");
  red_arrow = loadImage("assets/red_arrow.png");
  title_screen_buttons = loadImage("assets/title_screen_buttons.png");
  for (int i = 0; i < explosion.length; i++) {
    explosion[i] = loadImage("assets/explosion/explode" + i + ".png");
  }
  for (int i = 0; i < num_lvls; i++) {
    door[i] = loadImage("assets/doors/door" + (i + 1) + ".png");
  }
  for (int i = 0; i < num_lvls; i++) {
    behind_door[i] = loadImage("assets/behind_doors/behind_door" + (i + 1) + ".png");
  }
  
  empty_list  = new IntList();
  
  lvl1_l1 = new IntList();
  for (int i = 1; i < 6; i++) {
    lvl1_l1.append(i);
  }
  lvl2_l1 = new IntList();
  for (int i = 6; i < 36; i++) {
    lvl2_l1.append(i);
  }
  lvl3_l1 = new IntList();
  for (int i = 36; i < 46; i++) {
    lvl3_l1.append(i);
  }
  lvl4_l1 = new IntList();
  for (int i = 46; i < 51; i++) {
    lvl4_l1.append(i);
  }
  
  lvl3_l2 = new IntList();
  for (int i = 1; i < 21; i++) {
    lvl3_l2.append(i);
  }
  lvl4_l2 = new IntList();
  for (int i = 21; i < 26; i++) {
    lvl4_l2.append(i);
  }
  
  lvl4_l3 = new IntList();
  for (int i = 1; i < 16; i++) {
    lvl4_l3.append(i);
  }
  
  lvl5_l1 = new IntList();
  for (int i = 1; i < 11; i++) {
    lvl5_l1.append(0);
  }
  lvl5_l2 = new IntList();
  for (int i = 1; i < 11; i++) {
    lvl5_l2.append(0);
  }
  lvl5_l3 = new IntList();
  for (int i = 1; i < 11; i++) {
    lvl5_l3.append(0);
  }
  
  title_screen = new TitleScreen();
  lvl1 = new Level(lvl1_l1, empty_list, empty_list, 1);
  lvl2 = new Level(lvl2_l1, empty_list, empty_list, 2);
  lvl3 = new Level(lvl3_l1, lvl3_l2, empty_list, 3);
  lvl4 = new Level(lvl4_l1, lvl4_l2, lvl4_l3, 4);
  lvl5 = new Level(lvl5_l1, lvl5_l2, lvl5_l3, 5);
  
  dialogue_tree = new ArrayList<StringDict>();
  lvl1_dialogue = new StringDict();
  lvl2_dialogue = new StringDict();
  lvl3_dialogue = new StringDict();
  lvl4_dialogue = new StringDict();
  lvl5_dialogue = new StringDict();
  load_dialogue();
  
  song.loop();
}

public void draw() {
  switch(screen) {
    case 0:
      title_screen.draw();
      break;
    case 1:
      lvl1.draw();
      break;
    case 2:
      lvl2.draw();
      break;
    case 3:
      lvl3.draw();
      break;
    case 4:
      lvl4.draw();
      break;
    case 5:
      lvl5.draw();
      break;
    case 6:
      image(tutorial, 0, 0);
      break;
  }
}

public void mousePressed() {
  switch(screen) {
    case 0:
      title_screen.mousePressed();
      break;
    case 1:
      lvl1.mousePressed();
      break;
    case 2:
      lvl2.mousePressed();
      break;
    case 3:
      lvl3.mousePressed();
      break;
    case 4:
      lvl4.mousePressed();
      break;
    case 5:
      lvl5.mousePressed();
      break;
    case 6:
      screen = 0;
      break;
  }
}

public void keyReleased() {
  switch(screen) {
    case 1:
      lvl1.keyReleased();
      break;
    case 2:
      lvl2.keyReleased();
      break;
    case 3:
      lvl3.keyReleased();
      break;
    case 4:
      lvl4.keyReleased();
      break;
    case 5:
      lvl5.keyReleased();
      break;
    case 6:
      screen = 0;
      break;
  }
}

public void debug_screen(String text) {
  textFont(arial);
  background(255);
  fill(0);
  textSize(50);
  textAlign(CENTER, CENTER); 
  text(text, width/2, height/2);
}
public void load_dialogue() {
  lvl1_dialogue.set("lvl1_d1",
    "Listen up, kid. You're in with \nthe mob now, and we got a job \nfor ya. To start, we need ya to \nblast that grid to \nsmithereens.");
  lvl1_dialogue.set("lvl1_d2",
    "You got explosives in the bags \non your belt, right? Good, if you \nneed to rotate em, just hit that \nR button.");
  lvl1_dialogue.set("lvl1_d3",
    "Now, the red area around the \nbomb is the explosion radius. \nYou only got one match, so you \ngotta be smart.");
  lvl1_dialogue.set("lvl1_d4",
    "This here's important so you \nbest listen up. Chain together \nthose explosions by putting a \nbomb in the radius \nof the one before it.");
  lvl1_dialogue.set("lvl1_pe", // pe stands for post explosion
    "Good job kid, your final score \nwas " + lvl1.get_score() + "%, but don't worry about \nthat none. Next round ya gonna \nhave more bombs, \ntrust me.");
  dialogue_tree.add(lvl1_dialogue);
  
  lvl2_dialogue.set("lvl2_d1",
    "Hey, check dis out. I hooked ya \nup wit' more bombs, savvy? \nNow ya should have plenty to \nwork with.");
  lvl2_dialogue.set("lvl2_d2",
    "Unfortunately, thanks to an \nunexplained explosion at the \nmatch factory, ya still only \ngot one match.");
  lvl2_dialogue.set("lvl2_pe",
    "Holy smokes, did you see that \nblast?! Your final score was \n" + lvl2.get_score() + "%.");
  dialogue_tree.add(lvl2_dialogue);
  
  lvl3_dialogue.set("lvl3_d1",
    "Okay, listen up, kid. This is ya \nfirst real gig, capisce? The \neggheads in the lab got \nsomethin' new for \nya to play with...");
  lvl3_dialogue.set("lvl3_d2",
    "STICKY BOMBS! They're like \nregular bombs, but smaller and \nonce ya put 'em down, they \nain't comin' back up.");
  lvl3_dialogue.set("lvl3_pe",
    "Your final score was " + lvl3.get_score() + "%, but \nya better keep ya score up, if ya \nknow what's good for ya, pal. \nOtherwise, the boss \nwill come knockin'.");
  dialogue_tree.add(lvl3_dialogue);
  
  lvl4_dialogue.set("lvl4_d1",
    "This is it, kid, the big bust \nwe've been preparing you for! \nThe eggheads cooked up \nsomething special \nfor the occasionâ€¦");
  lvl4_dialogue.set("lvl4_d2",
    "FRAGILE BOMBS! They're \nbigger than yer usual stuff. But \ndon't get any ideas, kid. They're \ndelicate flowers, so \nya can't rotate 'em.");
  lvl4_dialogue.set("lvl4_pe",
    "That was one helluva \nfireworks show! Your final score \nwas " + lvl4.get_score() + "%. Not bad, kid, not bad \nat all.");
  dialogue_tree.add(lvl4_dialogue);

  lvl5_dialogue.set("lvl5_d1",
    "Hey, welcome to freeplay mode. \nEvery time ya reset the level, \nwe'll give ya different bombs. \nGood luck, kid, ya \ngonna need it.");
  lvl5_dialogue.set("lvl5_pe",
    "Your final score was " + lvl5.get_score() + "%.");
  dialogue_tree.add(lvl5_dialogue);
}
class Level {
  Piece p;
  ArrayList<Piece> pieces;
  IntList normal_seed_list;
  IntList sticky_seed_list;
  IntList fragile_seed_list;
  IntList og_normal_seed_list;
  IntList og_sticky_seed_list;
  IntList og_fragile_seed_list;
  int[][] arr_index = new int[10][10];
  boolean piece_in_hand = false;
  boolean match_in_hand = false;
  boolean exploding = false;
  int explosion_index = 0;
  int x_pos;
  int y_pos;
  int lvl_index;
  int final_score = 0;
  int dialogue_index = 1;
  int[] rect_color = {0xFF7F7B3A, 0xFF424F47, 0xFF6B716C, 0xFF262C30, 0xFF2E3F3B};
  
  Level(IntList l1, IntList l2, IntList l3, int lvl_index_in) {
    pieces = new ArrayList<Piece>();
    
    normal_seed_list = l1;
    sticky_seed_list = l2;
    fragile_seed_list = l3;
    
    og_normal_seed_list = clone(l1);
    og_sticky_seed_list = clone(l2);
    og_fragile_seed_list = clone(l3);
    
    // Fill arr_index with -1s
    for (int i = 0; i < 10; i++) {
      for (int j = 0; j < 10; j++) {
        arr_index[i][j] = -1;
      }
    }
    
    lvl_index = lvl_index_in;
  }
  
  private IntList clone(IntList in) {
    IntList out = new IntList();
    for (int i = in.size() - 1; i >= 0; i--) {
      out.append(in.get(i));
    }
    
    return out;
  }
  
  private void draw_bg() {
    image(door[lvl_index - 1], 0, 0);
    
    // Draws the grid
    for (int i = 0; i < 720; i += 72) {
      for (int j = 0; j < 720; j += 72) {
        strokeWeight(2);
        stroke(20);
        noFill();
        square(i,j,72);
      }
    }
    
    // Draws all the past pieces
    for (int i = 0; i < pieces.size(); i++) {
      pieces.get(i).draw();
    }
    
    // Shows the door_bg image through the door wherever the bombs explode
    PImage maskImage = createImage(720, 720, RGB);
    maskImage.loadPixels();
    for (int i = 0; i < 10; i++) {
      for (int j = 0; j < 10; j++) {
        if (arr_index[j][i] == -2) {
          for (int x = j*72; x < (j+1)*72; x++) {
            for (int y = i*72; y < (i+1)*72; y++) {
              maskImage.pixels[y*720 + x] = color(255, 255, 255);
            }
          }
        }
      }
      maskImage.updatePixels();
      behind_door[lvl_index - 1].mask(maskImage);
      image(behind_door[lvl_index - 1], 0, 0);
    }
    
    // Draws a rectangle next to the grid to cover any pieces that go off the grid to the right
    fill(rect_color[lvl_index - 1]);
    noStroke();
    rect(721,0,360,720);
    stroke(0);
    
    // Draws the belt
    if (match_in_hand) {
      image(matchless_belt,720,0);
    }
    else {
      image(belt,720,0);
    }
    
    // Draws the mobster
    image(mobster, 0, 0);
    
    // Draws nums on the bags
    textFont(arial);
    textSize(40);
    textAlign(CENTER);
    fill(0);
    text(normal_seed_list.size(), 762, 130);
    text(sticky_seed_list.size(), 837, 150);
    text(fragile_seed_list.size(), 972, 142);
    
    // Draws the dialogue
    textSize(22);
    textAlign(LEFT);
    if (exploding) {
      text(dialogue_tree.get(lvl_index - 1).get("lvl" + (lvl_index) + "_pe"), 750, 210);
    }
    else {
      text(dialogue_tree.get(lvl_index - 1).get("lvl" + (lvl_index) + "_d" + (dialogue_index)), 750, 210);
    }
    
    // Hides dialogue buttons when there is no dialogue in that direction
    if (dialogue_index <= 1 || exploding) {
      fill(255);
      noStroke();
      rect(960, 300, 50, 50);
    }
    if (dialogue_index == dialogue_tree.get(lvl_index - 1).size() - 1 || exploding) {
      fill(255);
      noStroke();
      rect(1008, 300, 50, 50);
    }
  }
  
  private int canvas_to_grid(Piece p_in, String xy) {
    if (xy == "x") {
      return ((p_in.get_x() + p_in.get_bomb_x() + 38)/72) - 1;
    }
    else if (xy == "y") {
      return ((p_in.get_y() + p_in.get_bomb_y() + 38)/72) - 1;
    }
    else {
      print("Error in the canvas_to_grid function. Please enter \"x\" or \"y\"");
      return -1;
    }
  }
  
  private int snap(int pos) {
    if (pos % 72 > -70 && pos % 72 < -36) {
      return pos - 72 - (pos % 72);
    }
    else if (pos % 72 > 36) {
      return pos + 72 - (pos % 72);
    }
    else {
      return pos - (pos % 72);
    }
  }
  
  public int get_score() {
    return final_score;
  }
  
  public void reset_everything() {
    piece_in_hand = false;
    match_in_hand = false;
    exploding = false;
    explosion_index = 0;
    dialogue_index = 1;
    final_score = 0;
    
    // Remove all the saved pieces
    for (int i = pieces.size() - 1; i >= 0; i--) {
      pieces.remove(i);
    }
    
    // Fill arr_index with -1s
    for (int i = 0; i < 10; i++) {
      for (int j = 0; j < 10; j++) {
        arr_index[i][j] = -1;
      }
    }
    
    // Refill the bags
    normal_seed_list = clone(og_normal_seed_list);
    sticky_seed_list = clone(og_sticky_seed_list);
    fragile_seed_list = clone(og_fragile_seed_list);
  }
  
  public void draw() {
    draw_bg();
  
    if (piece_in_hand) {
      x_pos = mouseX - p.get_bomb_x();
      y_pos = mouseY - p.get_bomb_y();
      translate(x_pos, y_pos);
      p.draw();
    }
    else if (match_in_hand && !exploding) {
      translate(mouseX,mouseY);
      match.resize(30, 0);
      image(match, -20, -60);
    }
    
    // Draws the explosions when the bombs are lit
    if (exploding) {
      for (int i = 0; i < pieces.size(); i++) {
        Piece q = pieces.get(i);
        if (arr_index[canvas_to_grid(q, "x")][canvas_to_grid(q, "y")] == -2) {
          push();
          translate(q.get_x() + q.get_bomb_x(), q.get_y() + q.get_bomb_y());
          image(explosion[explosion_index], -100, -100);
          pop();
        }
      }
      if (frameCount%10 == 0 && explosion_index < explosion.length - 1) {
          explosion_index++;
      }
      
      // Draws the red arrow after bombs are lit
      float red_arrow_y = 0;
      float amplitude = 10; // the maximum displacement of the shape
      float period = 60; // the time it takes for one full oscillation in frames
      red_arrow_y = amplitude * sin(frameCount * TWO_PI / period);
      
      image(red_arrow, 2, red_arrow_y);
    }
  }
  
  public void mousePressed() {
    if (mouseX > 962 && mouseX < 1002 && mouseY > 366 && mouseY < 404) {
      reset_everything();
    }
    if (mouseX > 1010 && mouseX < 1050 && mouseY > 366 && mouseY < 404) {
      screen = 0;
    }
    if (!exploding) {
      if (mouseX > 962 && mouseX < 1002 && mouseY >  305 && mouseY < 345) {
        if (dialogue_index > 1) {
          dialogue_index--;
        }
      }
      if (mouseX > 1010 && mouseX < 1050 && mouseY > 305 && mouseY < 345) {
        if (dialogue_index < dialogue_tree.get(lvl_index - 1).size() - 1) {
          dialogue_index++;
        }
      }
      if (mouseX > 0 && mouseX < 720 && mouseY > 0 && mouseY < 720) { // If you're over the grid
        x_pos = snap(x_pos);
        y_pos = snap(y_pos);
        int mx = mouseX / 72;
        int my = mouseY / 72;
        
        // Placeing pieces
        if (piece_in_hand) { // If you have a piece in hand
          p.set_x(x_pos); // Save the location
          p.set_y(y_pos);
          p.move(p.get_x(), p.get_y());
          
          if (arr_index[canvas_to_grid(p, "x")][canvas_to_grid(p, "y")] != -1) { // If the square has a bomb, move the piece back so as to undo the above move action
            p.move(-p.get_x(), -p.get_y());
            p.set_x(0);
            p.set_y(0);
          }
          
          else { // If the square has no bomb, add the piece to the background, and save what piece is in that square to arr_index
            piece_in_hand = false;
            arr_index[canvas_to_grid(p, "x")][canvas_to_grid(p, "y")] = pieces.size();
            pieces.add(p);
          }
        }
        
        // Picking up pieces
        else if (arr_index[mx][my] >= 0) { // If you don't have a piece in hand, the square has a bomb, and...
          if (!match_in_hand && pieces.get(arr_index[mx][my]).get_gaussian_center() != 3) { // ...you don't have a match in hand, and the piece you are trying to pick up isn't sticky
            piece_in_hand = true;
            p = new Piece(pieces.get(arr_index[mx][my]).get_seed(), pieces.get(arr_index[mx][my]).get_gaussian_center()); // Copy the piece into the hand
            for (int i = 0; i < (pieces.get(arr_index[mx][my]).get_deg() / 90); i++) { // Rotate the piece to match its old orientation
              p.rotate_piece();
            }
            pieces.remove(arr_index[mx][my]); // Remove the piece from pieces
            for (int i = 0; i < 10; i++) { // Update all indices in arr_index to reflect the new version of the pieces list
              for (int j = 0; j < 10; j++) {
                if (arr_index[i][j] > arr_index[mx][my]) {
                  arr_index[i][j]--;
                }
              }
            }
            arr_index[mx][my] = -1; // Lastly remove the index from arr_index
          }
          else if (match_in_hand) { // ...you do have a match in hand
            pieces.get(arr_index[mx][my]).light(pieces, arr_index, arr_index[mx][my], 0);
            exploding = true;
            if (!muted) {
              sound.play();
            }
            for (int i = 0; i < 10; i++) {
              for (int j = 0; j < 10; j++) {
                if (arr_index[i][j] == -2) {
                final_score++;
                }
              }
            }
            load_dialogue();
          }
        }
      }
      
      // The get normal bomb button
      if (mouseX > 720 && mouseX < 800 && mouseY > 5 && mouseY < 150 && !match_in_hand) { // If you're over the button, get a new piece
        if (!piece_in_hand && normal_seed_list.size() > 0) {
          piece_in_hand = true;
          p = new Piece(normal_seed_list.get(normal_seed_list.size() - 1), 6);
          normal_seed_list.remove(normal_seed_list.size() - 1);
        }
        else if (piece_in_hand && p.get_gaussian_center() == 6) { // Can only put a piece back in if it's the same type
          piece_in_hand = false;
          normal_seed_list.append(p.get_seed());
        }
      }
      
      // The get sticky bomb button
      if (mouseX > 800 && mouseX < 875 && mouseY > 15 && mouseY < 170 && !match_in_hand) { // If you're over the button, get a new piece
        if (!piece_in_hand && sticky_seed_list.size() > 0) {
          piece_in_hand = true;
          p = new Piece(sticky_seed_list.get(sticky_seed_list.size() - 1), 3);
          sticky_seed_list.remove(sticky_seed_list.size() - 1);
        }
        else if (piece_in_hand && p.get_gaussian_center() == 3) { // Can only put a piece back in if it's the same type
          piece_in_hand = false;
          sticky_seed_list.append(p.get_seed());
        }
      }
      
      // The get fragile bomb button
      if (mouseX > 930 && mouseX < 1010 && mouseY > 25 && mouseY < 165 && !match_in_hand) { // If you're over the button, get a new piece
        if (!piece_in_hand && fragile_seed_list.size() > 0) {
          piece_in_hand = true;
          p = new Piece(fragile_seed_list.get(fragile_seed_list.size() - 1), 9);
          fragile_seed_list.remove(fragile_seed_list.size() - 1);
        }
        else if (piece_in_hand && p.get_gaussian_center() == 9) { // Can only put a piece back in if it's the same type
          piece_in_hand = false;
          fragile_seed_list.append(p.get_seed());
        }
      }
      
      // The get match button
      if (mouseX > 1015 && mouseX < 1080 && mouseY > 15 && mouseY < 155 && !piece_in_hand) { // If you're over the button, get a match
        if (match_in_hand) {
          match_in_hand = false;
        }
        else {
          match_in_hand = true;
        }
      }
    }
  }
  
  public void keyReleased() {
    if (key == 'r' && piece_in_hand) {
      p.rotate_piece();
    }
  }
}
class Piece {
  PShape p = createShape(GROUP);
  PVector min = new PVector(0,0);
  int seed = 0;
  int gaussian_center = 6;
  int x = 0;
  int y = 0;
  int bomb_x = 0;
  int bomb_y = 0;
  int deg = 0;
  PVector mins;
  
  Piece(int seed_in, int gaussian_center_in) {
    // Set the seed
    if (seed_in == 0) {
      seed = round(random(1,1000));
    }
    else {
      seed = seed_in;
    }
    randomSeed(seed);
    
    // Sets the average piece size
    gaussian_center = gaussian_center_in;
    
    // Picks a random square on the grid to be the "snake head"
    int rx = 721;
    while (rx > 720) {
      rx = round(random(0,10))*72 + 72/2;
    }
    int ry = 721;
    while (ry > 720) {
      ry = round(random(0,10))*72 + 72/2;
    }
    style_piece();
    p.addChild(createShape());
    p.getChild(0).beginShape();
    p.getChild(0).vertex(rx-36,ry-36);
    p.getChild(0).vertex(rx+36,ry-36);
    p.getChild(0).vertex(rx+36,ry+36);
    p.getChild(0).vertex(rx-36,ry+36);
    p.getChild(0).endShape(CLOSE);
    
    // Picks a random square adjacent to "the head" and moves "the head" there
    // Repeat n times. So a larger n means a larger piece
    int n = round(randomGaussian() + gaussian_center);
    int nesw;
    boolean skip;
    for (int i = 0; i < n; i++) {
      nesw = round(random(0,3));
      skip = false;
      switch(nesw) {
        case 0: // Go north
          if (ry - 72 < 0) {
            i--;
            skip = true;
            break;
          }
          else {
            ry -= 72;
            break;
          }
        case 1: // Go east
          if (rx + 72 > 720) {
            i--;
            skip = true;
            break;
          }
          else {
            rx += 72;
            break;
          }
        case 2: // Go south
          if (ry + 72 > 720) {
            i--;
            skip = true;
            break;
          }
          else {
            ry += 72;
            break;
          }
        case 3: // Go west
          if (rx - 72 > 720) {
            i--;
            skip = true;
            break;
          }
          else {
            rx -= 72;
            break;
          }
        default:
          print("Error default case called");
          break;
      }
      p.addChild(createShape());
      if (!skip) {
        if (i == n/2) {
          bomb_x = rx;
          bomb_y = ry;
        }
        p.getChild(i+1).beginShape();
        p.getChild(i+1).vertex(rx-36,ry-36);
        p.getChild(i+1).vertex(rx+36,ry-36);
        p.getChild(i+1).vertex(rx+36,ry+36);
        p.getChild(i+1).vertex(rx-36,ry+36);
        p.getChild(i+1).endShape(CLOSE);
      }
    }
    
    int bomb_i = p.getChildCount();
    p.addChild(createShape());
    p.getChild(bomb_i).beginShape();
    p.getChild(bomb_i).vertex(bomb_x-4,bomb_y-4);
    p.getChild(bomb_i).vertex(bomb_x+4,bomb_y-4);
    p.getChild(bomb_i).vertex(bomb_x+4,bomb_y+4);
    p.getChild(bomb_i).vertex(bomb_x-4,bomb_y+4);
    p.getChild(bomb_i).endShape(CLOSE);
    
    // Translates the shape to 0, 0
    min = get_mins(p);
    p.translate(-min.x,-min.y);
    
    // Saves bomb x and bomb y
    PVector bomb_vertex = p.getChild(p.getChildCount()-1).getVertex(0);
    bomb_x = round(bomb_vertex.x - min.x + 2);
    bomb_y = round(bomb_vertex.y - min.y + 2);
    
    // Remove duplicate children
    // Running it once doesn't always catch them all
    remove_duplicate_children(p);
    remove_duplicate_children(p);
    
    // Same here. I have to run remove_null_children a ton if I want to get them all. IDK why
    for (int ci = 0; ci < p.getChildCount(); ci++) {
      remove_null_children(p);
    }
  }
  
  private void style_piece() {
    noStroke();
    fill(219,85,34,180);
  }
  
  private PVector get_mins(PShape p) {
    // Makes a list of the vertices
    ArrayList<PVector> vertices = new ArrayList<PVector>();
    for (int ci = 0; ci < p.getChildCount(); ci++) {
      for (int vi = 0; vi < p.getChild(ci).getVertexCount(); vi++) {
        vertices.add(p.getChild(ci).getVertex(vi));
      }
    }
    
    // Finds the upper left corner of the piece
    int[] xs = new int[vertices.size()];
    int[] ys = new int[vertices.size()];
    for (int i = 0; i < vertices.size(); i++) {
      xs[i] = (int)vertices.get(i).x;
      ys[i] = (int)vertices.get(i).y;
    }
    
    mins = new PVector(min(xs), min(ys));
    return mins;
  }
  
  private void remove_duplicate_children(PShape p) {
    for (int ci = 0; ci < p.getChildCount(); ci++) {
      for (int cj = ci + 1; cj < p.getChildCount(); cj++) {
        if (p.getChild(ci).getVertexCount() != p.getChild(cj).getVertexCount()) {
          continue;
        }
        int count = 0;
        for (int vi = 0; vi < p.getChild(ci).getVertexCount(); vi++) {
          PVector vertex_i = p.getChild(ci).getVertex(vi);
          for (int vj = 0; vj < p.getChild(cj).getVertexCount(); vj++) {
            PVector vertex_j = p.getChild(cj).getVertex(vj);
            if (vertex_i.equals(vertex_j)) {
              count++;
            }
          }
        }
        if (count == 4) {
          p.removeChild(cj);
        }
      }
    }
  }
  
  private void remove_null_children(PShape p) {
    for (int ci = 0; ci < p.getChildCount(); ci++) {
      if (p.getChild(ci).getVertexCount() == 0) {
        p.removeChild(ci);
      }
    }
  }
  
  public void move(int x_in, int y_in) {
    p.translate(x_in, y_in);
  }
  
  public void rotate_piece() {
    if (gaussian_center != 9) { // Fragile bombs have a gaussian_center of 9, and they can't be rotated
      style_piece();
      
      deg += 90;
      if (deg == 360) {
        deg = 0;
      }
      
      PShape rotated_piece = createShape(GROUP);
  
      // Copy the original shape into the rotated piece
      for (int ci = 0; ci < p.getChildCount(); ci++) {
        rotated_piece.addChild(createShape());
        rotated_piece.getChild(ci).beginShape();
        for (int vi = 0; vi < p.getChild(ci).getVertexCount(); vi++) {
          PVector original_vertex = p.getChild(ci).getVertex(vi);
          rotated_piece.getChild(ci).vertex(-original_vertex.y, original_vertex.x);
        }
        rotated_piece.getChild(ci).endShape(CLOSE);
      }
      
      min = get_mins(rotated_piece);
      rotated_piece.translate(-min.x,-min.y);
      
      // Saves bomb x and bomb y
      if (deg == 0) {
        PVector bomb_vertex = rotated_piece.getChild(rotated_piece.getChildCount()-1).getVertex(0);
        bomb_x = round(bomb_vertex.x - min.x + 2);
        bomb_y = round(bomb_vertex.y - min.y + 2);
      }
      if (deg == 90) {
        PVector bomb_vertex = rotated_piece.getChild(rotated_piece.getChildCount()-1).getVertex(0);
        bomb_x = round(bomb_vertex.x - min.x - 4);
        bomb_y = round(bomb_vertex.y - min.y + 2);
      }
      if (deg == 180) {
        PVector bomb_vertex = rotated_piece.getChild(rotated_piece.getChildCount()-1).getVertex(0);
        bomb_x = round(bomb_vertex.x - min.x - 4);
        bomb_y = round(bomb_vertex.y - min.y - 4);
      }
      if (deg == 270) {
        PVector bomb_vertex = rotated_piece.getChild(rotated_piece.getChildCount()-1).getVertex(0);
        bomb_x = round(bomb_vertex.x - min.x + 2);
        bomb_y = round(bomb_vertex.y - min.y - 4);
      }
      
      p = rotated_piece;
    }
  }
  
  public void light(ArrayList<Piece> pieces, int[][] arr_index, int this_index, int depth) {
    // Maximum depth allowed before stopping the recursion
    int maxDepth = 1000; // You can adjust this value as needed

    if (depth > maxDepth) {
        System.err.println("Error: Maximum recursion depth exceeded.");
        return;
    }
    
    for (int ci = 0; ci < p.getChildCount() - 1; ci++) {
      // Gets the top left vertex
      int smallest_cx = 9999;
      int smallest_cy = 9999;
      int cx = 0;
      int cy = 0;
      for (int vi = 0; vi < 4; vi++) {
        cx = (int)((p.getChild(ci).getVertex(vi).x - min.x + x) / 72);
        cy = (int)((p.getChild(ci).getVertex(vi).y - min.y + y) / 72);
        if (cx < smallest_cx) {
          smallest_cx = cx;
        }
        if (cy < smallest_cy) {
          smallest_cy = cy;
        }
      }
      cx = smallest_cx;
      cy = smallest_cy;
      if (cx < 0 || cx > 9 || cy < 0 || cy > 9) { // Stops out of bounds exception from being thrown when pieces go off the board
        continue;
      }
      if (arr_index[cx][cy] == -2) {
        continue;
      }
      else if ((arr_index[cx][cy] == -1) || (arr_index[cx][cy] == this_index)) {
        arr_index[cx][cy] = -2;
      }
      else if (arr_index[cx][cy] >= 0) {
        pieces.get(arr_index[cx][cy]).light(pieces, arr_index, arr_index[cx][cy], depth + 1);
      }
    }
  }
  
  public void draw() {
    shape(p);
    if (gaussian_center == 6) {
      noTint();
    }
    else if (gaussian_center == 3) {
      tint(0, 255, 0);
    }
    else if (gaussian_center == 9) {
      tint(255, 0, 0);
    }
    imageMode(CENTER);
    image(bomb, x + bomb_x + 1, y + bomb_y + 1);
    imageMode(CORNER);
    noTint();
  }
  
  // Setters
  public void set_x(int x_in) {
    x = x_in;
  }
  
  public void set_y(int y_in) {
    y = y_in;
  }
  
  // Getters
  public int get_min_x() {
    return (int)min.x;
  }
  
  public int get_min_y() {
    return (int)min.y;
  }
  
  public int get_seed() {
    return seed;
  }
  
  public int get_gaussian_center() {
    return gaussian_center;
  }
  
  public int get_x() {
    return x;
  }
  
  public int get_y() {
    return y;
  }
  
  public int get_bomb_x() {
    return bomb_x;
  }
  
  public int get_bomb_y() {
    return bomb_y;
  }
  
  public int get_deg() {
    return deg;
  }
}
class TitleScreen {
  int sign_y;
  int clock;
  boolean[] light_on;
  boolean lvl_selector;
  int white = color(255);
  int gold = color(213, 177, 115);
  int c0;
  int c1;
  int c2;
  int c3;
  int c4;
  int c5;
  
  TitleScreen() {
    sign_y = -600;
    clock = 0;
    light_on = new boolean [5];
    lvl_selector = false;
  }
  
  private void flash_lights() {
    fill(0);
    noStroke();
    clock += 2;
    if (clock > 350) { // Resets the clock
      clock = 100;
    }
    // If any of the lights are off, cover them with a black rectangle
    // Also, don't draw any rectangles till the sign slides in (at clock == 100)
    if (light_on[0] == false && clock > 100) {
      rect(660,336,60,60);
    }
    if (light_on[1] == false && clock > 100) {
      rect(820,336,60,60);
    }
    if (light_on[2] == false && clock > 100) {
      rect(880,336,60,60);
    }
    if (light_on[3] == false && clock > 100) {
      rect(940,336,60,60);
    }
    if (light_on[4] == false && clock > 100) {
      rect(1000,336,60,60);
    }
    // Flash the lights based on the clock
    if (clock >= 100 && clock < 150) {
      light_on[0] = false;
      light_on[1] = true;
      light_on[2] = true;
      light_on[3] = true;
      light_on[4] = true;
    }
    if (clock > 150 && clock < 200) {
      light_on[0] = true;
      light_on[1] = false;
      light_on[2] = true;
      light_on[3] = true;
      light_on[4] = true;
    }
    if (clock > 200 && clock < 250) {
      light_on[0] = true;
      light_on[1] = true;
      light_on[2] = false;
      light_on[3] = true;
      light_on[4] = true;
    }
    if (clock > 250 && clock < 300) {
      light_on[0] = true;
      light_on[1] = true;
      light_on[2] = true;
      light_on[3] = false;
      light_on[4] = true;
    }
    if (clock > 300) {
      light_on[0] = true;
      light_on[1] = true;
      light_on[2] = true;
      light_on[3] = true;
      light_on[4] = false;
    }
  }
  
  private void draw_lvl_label(int x, int y, int w, String label, int c) {
    fill(0);
    stroke(c);
    strokeWeight(3);
    rectMode(CENTER);
    rect(x, y, w, 50);
    rectMode(CORNER);
    
    textAlign(LEFT);
    textFont(expo);
    fill(c);
    textSize(30);
    text(label, x - (w/2) + 10, y + 10);
  }
  
  public void draw() {
    image(cityscape, 0, 0);
    if (!lvl_selector) {
      translate(-510, 0);
      image(title_sign, 0, sign_y);  
      if (sign_y < -10) { // Makes the sign slide in from the top
        sign_y += 15;
      }
      flash_lights();
    }
    else {
      image(title_screen_buttons, 0, 0);
      if (muted) {
        fill(255);
        noStroke();
        rect(29, 626, 15, 30);
      }
      
      // Draws the lvl labels
      if (mouseX > 875 && mouseX < 1015 && mouseY > 505 && mouseY < 555 ){
        c0 = gold;
      }
      else {
        c0 = white;
      }
      if (mouseX > 93 && mouseX < 260 && mouseY > 283 && mouseY < 333 ){
        c1 = gold;
      }
      else {
        c1 = white;
      }
      if (mouseX > 315 && mouseX < 485 && mouseY > 175 && mouseY < 225 ){
        c2 = gold;
      }
      else {
        c2 = white;
      }
      if (mouseX > 545 && mouseX < 730 && mouseY > 115 && mouseY < 170 ){
        c3 = gold;
      }
      else {
        c3 = white;
      }
      if (mouseX > 795 && mouseX < 970 && mouseY > 75 && mouseY < 125 ){
        c4 = gold;
      }
      else {
        c4 = white;
      }
      if (mouseX > 110 && mouseX < 260 && mouseY > 25 && mouseY < 75 ){
        c5 = gold;
      }
      else {
        c5 = white;
      }
      
      draw_lvl_label(945, 530, 140, "TUTORIAL", c0);
      draw_lvl_label(180, 310, 160, "LEVEL ONE", c1);
      draw_lvl_label(400, 200, 165, "LEVEL TWO", c2);
      draw_lvl_label(640, 145, 180, "LEVEL THREE", c3);
      draw_lvl_label(885, 100, 175, "LEVEL FOUR", c4);
      draw_lvl_label(185, 50, 148, "FREEPLAY", c5);
    }
  }
  
  public void mousePressed() {
    if (!lvl_selector) {
      lvl_selector = true;
    }
    else {
      if (mouseX > 10 && mouseX < 45 && mouseY > 620 && mouseY < 660 ) {
        if (!muted) {
          song.amp(0);
        }
        else {
          song.amp(1);
        }
        muted = !muted;
      }
      if (mouseX > 10 && mouseX < 45 && mouseY > 665 && mouseY < 705 ) {
        sign_y = -600;
        clock = 0;
        lvl_selector = false;
      }
      if (c0 == gold) {
        screen = 6;
      }
      else if (c1 == gold) {
        screen = 1;
      }
      else if (c2 == gold) {
        screen = 2;
      }
      else if (c3 == gold) {
        screen = 3;
      }
      else if (c4 == gold) {
        screen = 4;
      }
      else if (c5 == gold) {
        screen = 5;
      }
    }
  }
}


  public void settings() { size(1080, 720); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "boom_bust_beta" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
